/**
 * Account and Transaction API SpecificationLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { array, lazy, object, optional, Schema, string } from '../schema';
import { Amount10, amount10Schema } from './amount10';
import { Balance2, balance2Schema } from './balance2';
import {
  BankTransactionCode2,
  bankTransactionCode2Schema,
} from './bankTransactionCode2';
import { CardInstrument2, cardInstrument2Schema } from './cardInstrument2';
import {
  CreditDebitIndicator1Enum,
  creditDebitIndicator1EnumSchema,
} from './creditDebitIndicator1Enum';
import { CreditorAccount5, creditorAccount5Schema } from './creditorAccount5';
import { CreditorAgent3, creditorAgent3Schema } from './creditorAgent3';
import {
  CurrencyExchange2,
  currencyExchange2Schema,
} from './currencyExchange2';
import { DebtorAccount2, debtorAccount2Schema } from './debtorAccount2';
import { DebtorAgent2, debtorAgent2Schema } from './debtorAgent2';
import { MerchantDetails2, merchantDetails2Schema } from './merchantDetails2';
import {
  ProprietaryBankTransactionCode2,
  proprietaryBankTransactionCode2Schema,
} from './proprietaryBankTransactionCode2';
import { Status1Enum, status1EnumSchema } from './status1Enum';
import {
  TransactionReference,
  transactionReferenceSchema,
} from './transactionReference';

export interface TransactionModel {
  /** A unique and immutable identifier used to identify the account resource. This identifier has no meaning to the account owner. */
  accountId: string;
  /** Unique identifier for the transaction within an servicing institution. This identifier is both unique and immutable. */
  transactionId?: string;
  transactionReference?: TransactionReference;
  /** Unique reference for the statement. This reference may be optionally populated if available. */
  statementReference?: string[];
  amount: Amount10;
  /** Indicates whether the transaction is a credit or a debit entry. */
  creditDebitIndicator: CreditDebitIndicator1Enum;
  /** Status of a transaction entry on the books of the account servicer. */
  status: Status1Enum;
  /**
   * Date and time when a transaction entry is posted to an account on the account servicer's books. Usage: Booking date is the expected booking date, unless the status is booked, in which case it is the actual booking date.
   * All dates in the JSON payloads are represented in ISO 8601 date-time format.
   * All date-time fields in responses must include the timezone. An example is below:
   * 2017-04-05T10:43:07+00:00
   */
  bookingDateTime: string;
  /**
   * Date and time at which assets become available to the account owner in case of a credit entry, or cease to be available to the account owner in case of a debit entry.  Usage: If entry status is pending and value date is present, then the value date refers to an expected/requested value date. For entries subject to availability/float and for which availability information is provided, the value date must not be used. In this case the availability component identifies the  number of availability days.
   * All dates in the JSON payloads are represented in ISO 8601 date-time format.
   * All date-time fields in responses must include the timezone. An example is below:
   * 2017-04-05T10:43:07+00:00
   */
  valueDateTime?: string;
  /** Information that locates and identifies a specific address, as defined by postal services, that is presented in free format text. */
  addressLine?: string;
  bankTransactionCode?: BankTransactionCode2;
  proprietaryBankTransactionCode?: ProprietaryBankTransactionCode2;
  currencyExchange?: CurrencyExchange2;
  creditorAgent?: CreditorAgent3;
  debtorAgent?: DebtorAgent2;
  cardInstrument?: CardInstrument2;
  /** Further details of the transaction. This is the transaction narrative, which is unstructured text. */
  transactionInformation?: string;
  balance?: Balance2;
  merchantDetails?: MerchantDetails2;
  creditorAccount?: CreditorAccount5;
  debtorAccount?: DebtorAccount2;
}

export const transactionModelSchema: Schema<TransactionModel> = object({
  accountId: ['AccountId', string()],
  transactionId: ['TransactionId', optional(string())],
  transactionReference: [
    'TransactionReference',
    optional(lazy(() => transactionReferenceSchema)),
  ],
  statementReference: ['StatementReference', optional(array(string()))],
  amount: ['Amount', lazy(() => amount10Schema)],
  creditDebitIndicator: [
    'CreditDebitIndicator',
    creditDebitIndicator1EnumSchema,
  ],
  status: ['Status', status1EnumSchema],
  bookingDateTime: ['BookingDateTime', string()],
  valueDateTime: ['ValueDateTime', optional(string())],
  addressLine: ['AddressLine', optional(string())],
  bankTransactionCode: [
    'BankTransactionCode',
    optional(lazy(() => bankTransactionCode2Schema)),
  ],
  proprietaryBankTransactionCode: [
    'ProprietaryBankTransactionCode',
    optional(lazy(() => proprietaryBankTransactionCode2Schema)),
  ],
  currencyExchange: [
    'CurrencyExchange',
    optional(lazy(() => currencyExchange2Schema)),
  ],
  creditorAgent: ['CreditorAgent', optional(lazy(() => creditorAgent3Schema))],
  debtorAgent: ['DebtorAgent', optional(lazy(() => debtorAgent2Schema))],
  cardInstrument: [
    'CardInstrument',
    optional(lazy(() => cardInstrument2Schema)),
  ],
  transactionInformation: ['TransactionInformation', optional(string())],
  balance: ['Balance', optional(lazy(() => balance2Schema))],
  merchantDetails: [
    'MerchantDetails',
    optional(lazy(() => merchantDetails2Schema)),
  ],
  creditorAccount: [
    'CreditorAccount',
    optional(lazy(() => creditorAccount5Schema)),
  ],
  debtorAccount: ['DebtorAccount', optional(lazy(() => debtorAccount2Schema))],
});
